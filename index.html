<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inbox Zero</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="stylesheet" type="text/css" href="icon-styles.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="card">
      <p>Inbox Zero</p>

      <div id="authorize_button">Authorize</div>

      <pre id="error"></pre>

      <div id="results"></div>
      <label id="filter" class="container" style="display: none;">Only scan unread emails
        <input id="unread_filter" type="checkbox" checked="checked">
        <span class="checkmark"></span>
      </label><br>
      <div id="estimate"></div>
      <div id="fetch_button">Fetch Emails</div>
      <div id="signout_button">Sign Out</div>
    </div>

    <script type="text/javascript">
      // Client ID and API key from keys.txt file
      fetch('keys.txt')
        .then(response => response.text())
        .then(text => parseKeys(text));

      let CLIENT_ID = '';
      let API_KEY = '';

      // Don't change this value, it is tweaked for the Gmail API rate limits
      const MAX_RESULTS = 200;
      const MILLIS_PER_EMAIL = 7;
      // const PAGE_LIMIT = 2;

      // Array of API discovery doc URLs for APIs used by the quickstart
      const DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'];

      // Authorization scopes required by the API; multiple scopes can be
      // included, separated by spaces.
      const SCOPES = 'https://www.googleapis.com/auth/gmail.readonly';

      const authorizeButton = document.getElementById('authorize_button');
      const signoutButton = document.getElementById('signout_button');
      const fetchButton = document.getElementById('fetch_button');
      const estimate = document.getElementById('estimate');
      const filterCheckbox = document.getElementById('filter');
      const unreadFilter = document.getElementById('unread_filter');

      const EXTERNAL_LINK_ICON = '<span class="icon-external-link"></span>';

      let pagesFetched = 0;
      let froms = {};
      let totalEmails = 0;
      let unreadEmails = 0;

      // TODO: Group by domain vs by sender name
      // TODO: Display data as it's being loaded
      // TODO: Progress bar

      /**
       *  On load, called to load the auth2 library and API client library.
       */
      function handleClientLoad() {
        gapi.load('client:auth2', initClient);
      }

      /**
       *  Initializes the API client library and sets up sign-in state
       *  listeners.
       */
      function initClient() {
        gapi.client.init({
          apiKey: API_KEY,
          clientId: CLIENT_ID,
          discoveryDocs: DISCOVERY_DOCS,
          scope: SCOPES,
        }).then(() => {
          // Listen for sign-in state changes.
          gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);

          // Handle the initial sign-in state.
          updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());
          authorizeButton.onclick = handleAuthClick;
          signoutButton.onclick = handleSignoutClick;
          fetchButton.onclick = handleFetchClick;
          unreadFilter.addEventListener('change', (event) => {
            if (event.target.checked) {
              fetchButton.innerHTML = `Fetch ${unreadEmails} emails`
              estimate.innerHTML = `Estimated time: ${millisToMinutes(unreadEmails * MILLIS_PER_EMAIL)}`
            } else {
              fetchButton.innerHTML = `Fetch ${totalEmails} emails`
              estimate.innerHTML = `Estimated time: ${millisToMinutes(totalEmails * MILLIS_PER_EMAIL)}`
            }
          })
        }, (error) => {
          var error = document.getElementById('error');
          error.style.display = 'block';
          const errorText = document.createTextNode(`${JSON.stringify(error, null, 2)}\n`);
          error.appendChild(errorText);
        });
      }

      /**
       *  Called when the signed in status changes, to update the UI
       *  appropriately. After a sign-in, the API is called.
       */
      function updateSigninStatus(isSignedIn) {
        if (isSignedIn) {
          authorizeButton.style.display = 'none';
          signoutButton.style.display = 'inline-block';
          fetchButton.style.display = 'inline-block';
          filterCheckbox.style.display = 'initial';
          fetchEmailCounts();
        } else {
          authorizeButton.style.display = 'block';
          signoutButton.style.display = 'none';
          fetchButton.style.display = 'none';
          filterCheckbox.style.display = 'none';
        }
      }

      /**
       *  Sign in the user upon button click.
       */
      function handleAuthClick(event) {
        gapi.auth2.getAuthInstance().signIn();
      }

      /**
       *  Sign out the user upon button click.
       */
      function handleSignoutClick(event) {
        gapi.auth2.getAuthInstance().signOut();
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
      }

      /**
       * Handle fetching emails upon button click.
       */
      function handleFetchClick(event) {
        pagesFetched = 0;
        froms = {};
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';
        fetchEmailCounts();
        listMessages();
      }

      function fetchEmailCounts() {
        gapi.client.gmail.users.labels.get({
            userId: 'me',
            id: 'INBOX'
          }).then(function(response) {
            totalEmails = response.result.messagesTotal;
            unreadEmails = response.result.messagesUnread;
            if (unreadFilter.checked) {
              fetchButton.innerHTML = `Fetch ${unreadEmails} emails`
              estimate.innerHTML = `Estimated time: ${millisToMinutes(unreadEmails * MILLIS_PER_EMAIL)}`
            } else {
              fetchButton.innerHTML = `Fetch ${totalEmails} emails`
              estimate.innerHTML = `Estimated time: ${millisToMinutes(totalEmails * MILLIS_PER_EMAIL)}`
            }
          });
      }

      function listMessages(pageToken) {
        gapi.client.gmail.users.messages.list({
          userId: 'me',
          maxResults: MAX_RESULTS,
          q: 'is:unread',
          pageToken,
        }).then((response) => {
          const { messages } = response.result;
          const { nextPageToken } = response.result;

          let responseCount = 0;

          if (unreadFilter.checked) {
            fetchButton.innerText = `Emails loading: ${pagesFetched * MAX_RESULTS}/${unreadEmails}`;
          } else {
            fetchButton.innerText = `Emails loading: ${pagesFetched * MAX_RESULTS}/${totalEmails}`;
          }

          pagesFetched += 1;

          fetchButton.classList.add('disabled');
          fetchButton.onclick = '';
          filterCheckbox.classList.add('disabled');
          unreadFilter.disabled = true;

          if (messages && messages.length > 0) {
            for (i = 0; i < messages.length; i++) {
              const message = messages[i];
              var printTimeout = 0;
              setTimeout((msg) => {
                gapi.client.gmail.users.messages.get({
                  userId: 'me',
                  id: msg.id,
                }).then((response) => {
                  // getFrom(response.result.payload.headers);
                  getFrom(response.result);
                  responseCount += 1;
                  if (responseCount >= MAX_RESULTS && nextPageToken/* && pagesFetched < PAGE_LIMIT*/) {
                    listMessages(nextPageToken);
                  } else if (!nextPageToken/* || pagesFetched >= PAGE_LIMIT*/) {
                    clearTimeout(printTimeout);
                    printTimeout = setTimeout(() => {
                      enableControls();

                      printFroms();
                    }, 2000);
                  }
                }, (error) => {
                  printError(error);
                });
              }, i * MILLIS_PER_EMAIL, message);
            }
          }
        }, (error) => {
          printError(error);
        });
      }

      function parseKeys(text) {
        CLIENT_ID = text.substring(text.indexOf('CLIENT_ID=') + 10, text.indexOf('\n')).replace(/\s/g, '');
        API_KEY = text.substring(text.indexOf('API_KEY=') + 8).replace(/\s/g, '');
      }

      function enableControls() {
        fetchButton.innerText = 'Fetch Emails';
        fetchButton.classList.remove('disabled');
        fetchButton.onclick = handleFetchClick;
        filterCheckbox.classList.remove('disabled');
        unreadFilter.disabled = false;
      }

      function printError(err) {
        enableControls();
        const error = document.getElementById('error');
        error.style.display = 'block';
        const errorText = document.createTextNode(`Error code ${err.result.error.code}: ${err.result.error.message}\n`);
        error.appendChild(errorText);
      }

      function getFrom(result) {
        let from = null;
        let subject = '';
        for (i = 0; i < result.payload.headers.length; i++) {
          if (result.payload.headers[i].name === 'From') {
            from = result.payload.headers[i].value;
          } else if (result.payload.headers[i].name === 'Subject') {
            subject = result.payload.headers[i].value;
          }
        }

        if (from) {
          if (froms[from]) {
            froms[from].count = froms[from].count + 1;
            froms[from].emails.push({
              snippet: result.snippet,
              date: result.internalDate,
              subject,
            });
          } else {
            froms[from] = {
              count: 1,
              emails: [{
                snippet: result.snippet,
                date: result.internalDate,
                subject,
              }],
            };
          }
        }
      }

      function millisToMinutes(millis) {
        var minutes = Math.ceil(millis / 60000);
        return minutes + " " + (minutes===1?"minute":"minutes");
      }

      function printFroms() {
        const resultsDiv = document.getElementById('results');

        // Create items array
        const items = Object.keys(froms).map(key => [key, froms[key].count, froms[key].emails]);

        // Sort the array based on the second element
        items.sort((first, second) => second[1] - first[1]);

        for (i = 0; i < items.length; i++) {
          resultsDiv.appendChild(generateEmailList(items[i]));
        }
      }

      function generateEmailList(item) {
        const newDiv = document.createElement('div');
        newDiv.className = 'accordion';
        const childDiv = document.createElement('div');
        childDiv.className = 'panel';

        newDiv.innerText = item[0];

        let lastDate = 0;
        for (j = 0; j < item[2].length; j++) {
          if (item[2][j].date > lastDate) {
            lastDate = item[2][j].date;
          }
          childDiv.innerHTML += item[2][j].subject.replace(/\u200C/g, '?');
          const divider = document.createElement('div');
          divider.className = 'divider';
          childDiv.appendChild(divider);
        }
        const date = new Date(parseInt(lastDate, 10));
        const year = date.getFullYear();
        const month = (`0${date.getMonth() + 1}`).slice(-2);
        const day = (`0${date.getDate()}`).slice(-2);

        let from = '';
        if (item[0].indexOf('>') > 0) {
          from = item[0].substring(item[0].indexOf('<') + 1, item[0].indexOf('>'));
        } else {
          from = item[0];
        }

        newDiv.innerHTML = `${newDiv.innerHTML} <span class='unreads'>(<a href='https://mail.google.com/mail/u/0/#search/is%3Aunread+from%3A${from}' target='_blank'>${item[1]} unread ${EXTERNAL_LINK_ICON}</a>)</span>`;
        newDiv.innerHTML = `${newDiv.innerHTML}<span class='date-float'> Last email: ${month}-${day}-${year}</span>`;
        newDiv.appendChild(childDiv);

        newDiv.addEventListener('click', function () {
          this.classList.toggle('active');
          childDiv.classList.toggle('expanded');
        });
        return newDiv;
      }
    </script>

    <script async defer src="https://apis.google.com/js/api.js"
      onload="this.onload=function(){};handleClientLoad()"
      onreadystatechange="if (this.readyState === 'complete') this.onload()">
    </script>
  </body>
</html>
